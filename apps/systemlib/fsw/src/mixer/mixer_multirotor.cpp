#include "mixer.h"
#include <math.h>
#include <string.h>
#include "lib/math/Limits.hpp"
#include <float.h>

// This file is generated by the multi_tables script which is invoked during the build process
//#include "mixer_multirotor.generated.h"

/*
 * Clockwise: 1
 * Counter-clockwise: -1
 */

MultirotorMixer::MultirotorMixer(ControlCallback control_cb,
				 cpuaddr cb_handle,
				 MultirotorGeometry geometry,
				 float roll_scale,
				 float pitch_scale,
				 float yaw_scale,
				 float idle_speed) :
    Mixer(control_cb, cb_handle),
    m_RollScale(roll_scale),
    m_PitchScale(pitch_scale),
    m_YawScale(yaw_scale),
    m_IdleSpeed(-1.0f + idle_speed * 2.0f), /* shift to output range here to avoid runtime calculation */
    m_DeltaOutMax(0.0f),
    m_ThrustFactor(0.0f),
    m_OutputsPrev(new float[8])
{
    memset(m_OutputsPrev, m_IdleSpeed, 8 * sizeof(float));
}

MultirotorMixer::~MultirotorMixer()
{
    if (m_OutputsPrev != nullptr) {
        delete[] m_OutputsPrev;
    }
}

uint32
MultirotorMixer::mix(float *outputs, uint32 space, uint16 *status_reg)
{
    /* Summary of mixing strategy:
    1) mix roll, pitch and thrust without yaw.
    2) if some outputs violate range [0,1] then try to shift all outputs to minimize violation ->
        increase or decrease total thrust (boost). The total increase or decrease of thrust is limited
        (max_thrust_diff). If after the shift some outputs still violate the bounds then scale roll & pitch.
        In case there is violation at the lower and upper bound then try to shift such that violation is equal
        on both sides.
    3) mix in yaw and scale if it leads to limit violation.
    4) scale all outputs to range [idle_speed,1]
    */

    float       roll    = math::constrain(get_control(0, 0) * m_RollScale, -1.0f, 1.0f);
    float       pitch   = math::constrain(get_control(0, 1) * m_PitchScale, -1.0f, 1.0f);
    float       yaw     = math::constrain(get_control(0, 2) * m_YawScale, -1.0f, 1.0f);
    float       thrust  = math::constrain(get_control(0, 3), 0.0f, 1.0f);
    float       min_out = 1.0f;
    float       max_out = 0.0f;

    // clean out class variable used to capture saturation
    m_SaturationStatus.value = 0;

    // thrust boost parameters
    float thrust_increase_factor = 1.5f;
    float thrust_decrease_factor = 0.6f;

    /* perform initial mix pass yielding unbounded outputs, ignore yaw */
    for (uint32 i = 0; i < m_RotorCount; i++) {
        float out = roll * m_Rotors[i].roll_scale +
                pitch * m_Rotors[i].pitch_scale +
                thrust;

        out *= m_Rotors[i].out_scale;

        /* calculate min and max output values */
        if (out < min_out) {
            min_out = out;
        }

        if (out > max_out) {
            max_out = out;
        }

        outputs[i] = out;
    }

    float boost = 0.0f;     // value added to demanded thrust (can also be negative)
    float roll_pitch_scale = 1.0f;  // scale for demanded roll and pitch

    if (min_out < 0.0f && max_out < 1.0f && -min_out <= 1.0f - max_out) {
        float max_thrust_diff = thrust * thrust_increase_factor - thrust;

        if (max_thrust_diff >= -min_out) {
            boost = -min_out;

        } else {
            boost = max_thrust_diff;
            roll_pitch_scale = (thrust + boost) / (thrust - min_out);
        }

    } else if (max_out > 1.0f && min_out > 0.0f && min_out >= max_out - 1.0f) {
        float max_thrust_diff = thrust - thrust_decrease_factor * thrust;

        if (max_thrust_diff >= max_out - 1.0f) {
            boost = -(max_out - 1.0f);

        } else {
            boost = -max_thrust_diff;
            roll_pitch_scale = (1 - (thrust + boost)) / (max_out - thrust);
        }

    } else if (min_out < 0.0f && max_out < 1.0f && -min_out > 1.0f - max_out) {
        float max_thrust_diff = thrust * thrust_increase_factor - thrust;
        boost = math::constrain(-min_out - (1.0f - max_out) / 2.0f, 0.0f, max_thrust_diff);
        roll_pitch_scale = (thrust + boost) / (thrust - min_out);

    } else if (max_out > 1.0f && min_out > 0.0f && min_out < max_out - 1.0f) {
        float max_thrust_diff = thrust - thrust_decrease_factor * thrust;
        boost = math::constrain(-(max_out - 1.0f - min_out) / 2.0f, -max_thrust_diff, 0.0f);
        roll_pitch_scale = (1 - (thrust + boost)) / (max_out - thrust);

    } else if (min_out < 0.0f && max_out > 1.0f) {
        boost = math::constrain(-(max_out - 1.0f + min_out) / 2.0f, thrust_decrease_factor * thrust - thrust,
                    thrust_increase_factor * thrust - thrust);
        roll_pitch_scale = (thrust + boost) / (thrust - min_out);
    }

    // capture saturation
    if (min_out < 0.0f) {
        m_SaturationStatus.flags.motor_neg = true;
    }

    if (max_out > 1.0f) {
        m_SaturationStatus.flags.motor_pos = true;
    }

    // Thrust reduction is used to reduce the collective thrust if we hit
    // the upper throttle limit
    float thrust_reduction = 0.0f;

    // mix again but now with thrust boost, scale roll/pitch and also add yaw
    for (uint32 i = 0; i < m_RotorCount; i++) {
        float out = (roll * m_Rotors[i].roll_scale +
                 pitch * m_Rotors[i].pitch_scale) * roll_pitch_scale +
                yaw * m_Rotors[i].yaw_scale +
                thrust + boost;

        out *= m_Rotors[i].out_scale;

        // scale yaw if it violates limits. inform about yaw limit reached
        if (out < 0.0f) {
            if (fabsf(m_Rotors[i].yaw_scale) <= FLT_EPSILON) {
                yaw = 0.0f;

            } else {
                yaw = -((roll * m_Rotors[i].roll_scale + pitch * m_Rotors[i].pitch_scale) *
                    roll_pitch_scale + thrust + boost) / m_Rotors[i].yaw_scale;
            }

        } else if (out > 1.0f) {
            // allow to reduce thrust to get some yaw response
            float prop_reduction = fminf(0.15f, out - 1.0f);
            // keep the maximum requested reduction
            thrust_reduction = fmaxf(thrust_reduction, prop_reduction);

            if (fabsf(m_Rotors[i].yaw_scale) <= FLT_EPSILON) {
                yaw = 0.0f;

            } else {
                yaw = (1.0f - ((roll * m_Rotors[i].roll_scale + pitch * m_Rotors[i].pitch_scale) *
                           roll_pitch_scale + (thrust - thrust_reduction) + boost)) / m_Rotors[i].yaw_scale;
            }
        }
    }

    // Apply collective thrust reduction, the maximum for one prop
    thrust -= thrust_reduction;

    // add yaw and scale outputs to range idle_speed...1
    for (unsigned i = 0; i < m_RotorCount; i++) {
        outputs[i] = (roll * m_Rotors[i].roll_scale +
                  pitch * m_Rotors[i].pitch_scale) * roll_pitch_scale +
                 yaw * m_Rotors[i].yaw_scale +
                 thrust + boost;

        /*
            implement simple model for static relationship between applied motor pwm and motor thrust
            model: thrust = (1 - _thrust_factor) * PWM + _thrust_factor * PWM^2
            this model assumes normalized input / output in the range [0,1] so this is the right place
            to do it as at this stage the outputs are in that range.
         */
        if (m_ThrustFactor > 0.0f) {
            outputs[i] = -(1.0f - m_ThrustFactor) / (2.0f * m_ThrustFactor) + sqrtf((1.0f - m_ThrustFactor) *
                    (1.0f - m_ThrustFactor) / (4.0f * m_ThrustFactor * m_ThrustFactor) + (outputs[i] < 0.0f ? 0.0f : outputs[i] /
                            m_ThrustFactor));
        }

        outputs[i] = math::constrain(m_IdleSpeed + (outputs[i] * (1.0f - m_IdleSpeed)), m_IdleSpeed, 1.0f);

    }

    /* slew rate limiting and saturation checking */
    for (uint32 i = 0; i < m_RotorCount; i++) {
        bool clipping_high = false;
        bool clipping_low = false;

        // check for saturation against static limits
        if (outputs[i] > 0.99f) {
            clipping_high = true;

        } else if (outputs[i] < m_IdleSpeed + 0.01f) {
            clipping_low = true;

        }

        // check for saturation against slew rate limits
        if (m_DeltaOutMax > 0.0f) {
            float delta_out = outputs[i] - m_OutputsPrev[i];

            if (delta_out > m_DeltaOutMax) {
                outputs[i] = m_OutputsPrev[i] + m_DeltaOutMax;
                clipping_high = true;

            } else if (delta_out < -m_DeltaOutMax) {
                outputs[i] = m_OutputsPrev[i] - m_DeltaOutMax;
                clipping_low = true;

            }
        }

        m_OutputsPrev[i] = outputs[i];

        // update the saturation status report
        update_saturation_status(i, clipping_high, clipping_low);

    }

    // this will force the caller of the mixer to always supply new slew rate values, otherwise no slew rate limiting will happen
    m_DeltaOutMax = 0.0f;

    // Notify saturation status
    if (status_reg != nullptr) {
        (*status_reg) = m_SaturationStatus.value;
    }

    return m_RotorCount;
}

/*
 * This function update the control saturation status report using hte following inputs:
 *
 * index: 0 based index identifying the motor that is saturating
 * clipping_high: true if the motor demand is being limited in the positive direction
 * clipping_low: true if the motor demand is being limited in the negative direction
*/
void
MultirotorMixer::update_saturation_status(uint32 index, bool clipping_high, bool clipping_low)
{

}

void
MultirotorMixer::groups_required(uint32 &groups)
{

}

uint16 MultirotorMixer::get_saturation_status()
{
	return 0;
}
