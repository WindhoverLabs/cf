"""Consumer.py is the final destination of all websocket routing that happens in django. Each incoming message is picked
up by one of the several workers and gets routed to respective function call in this file. The worker executes the function
passing the message as parameter. The response is written in the received message itself and put back on the channel/socket.
"""

## swiss-knife
import toolkit as tk
import urllib,json,os,psutil,requests,time,socket,base64
from channels import Group
from websocket import create_connection
from multiprocessing import Process
## datastores
import redis,sqlite3



class Telemetry:
    """!
    Deals with telemetry specific interactions between client and server.
    """

    def __init__(self):
        """!
        Initializes globally required variables from redis cache and other data structures that are helpful in tracking
        messages when the instance of this class is called in a multiprocess setting (or with multiple workers).
        """
        ## Initialize redis caching database
        self.redis_cache = redis.StrictRedis(host='localhost', port=6379, db=0)

        ## Initialize mode defined in launch_config.json
        self.mode = int(self.redis_cache.get('mode'))

        ## Initialize test database path defined in launch_config.json
        self.test_db_path = self.redis_cache.get('app_path')

        ## Initialize number or parallel workers defined in launch_config.json
        self.number_of_workers = self.redis_cache.get('number_of_workers')

        ## Initialize default instance defined in launch_config.json
        self.defaultInstance= self.redis_cache.get('instance')

        ## Initialize address to pyliner/yamcs defined in launch_config.json
        self.address = self.redis_cache.get('address')

        ## Initialize port to pyliner/yamcs defined in launch_config.json
        self.port = self.redis_cache.get('port')

        ## A dictionary to store websockets which connect backend, mapped with unique id in message object.
        self.sock_map = {}

        ## A dictionary to store processes which push telemetry to frontend, mapped with unique id in message object.
        self.proc_map = {}

        ## The number of samples collected everytime the `push` function yields data
        self.test_sampling_frequency = (1.0/10)

    def connect(self, message):
        """!
        Accepts request and establishes a connection with client.
        @param message: connection request from client, this message will connection headers.
        @return: void
        """
        Group('tlm_bc').add(message.reply_channel)
        message.reply_channel.send({'accept': True})
        tk.log('Instance', 'Connected.', 'INFO')

    def disconnect(self, message):
        """!
        Accepts disconnection message and disconnects with client.
        @param message: disconnection request from client, this message will disconnection headers.
        @return: void
        """
        message.reply_channel.send({'close': True})
        Group('tlm_bc').discard(message.reply_channel)
        tk.log('Instance', '(Dis)connected.', 'INFO')

    def test_db_wrapper(self,input,output,code,desc):
        """!
        This is a hook to record inputs and subsequent outputs that are generated by Telemetry.
        @param input: a string object before a certain process is applied on it.
        @param output: a string object after the process is applied on it.
        @param code: a user defined string, categorizes various database entries.
        @param desc: description of the process that is applied on the input.
        @return: void
        """
        if self.mode == 0:
            try:
                conn = sqlite3.connect(self.test_db_path + '/test_database', timeout=5)
                tk.collectTestCases(conn, code, input, output, desc)
                conn.commit()
                conn.close()
                tk.log('Train', 'Item inserted in database.', 'DEBUG')
            except:
                ## TODO: safely log error, unit test required
                tk.log('Train', 'NA', 'ERROR')
                pass

    def getTelemetry(self, message):
        """!
        Takes the telemetry message object and either sends a subscribe or unsubscribe signal to pyliner/yamcs.
        Creates or destroys `push` processes based on signal received.
        @param message: telemetry message object is sent from the client.
        @return: void
        """
        message_client_id = message.content['reply_channel']
        ## clean text
        message_text = tk.byteify(message.content['text'])
        ## unsubscribe signal
        if message_text.find('kill_tlm') != -1:
            try:
                msg = message_text.replace('kill_tlm', '')
                msg_text_obj = json.loads(msg)
                temp = ' {"parameter":"unsubscribe", "data":{"list":' + str(tk.byteify(msg_text_obj['tlm'])) + '}}'
                temp = temp.replace("\'", "\"")
                to_send = '[1,1,0,' + str(temp) + ']'
                ## Train
                self.test_db_wrapper(message_text,'null','KILTLM','unsubscribe telemetry')
                ## sending unsubscribe signal to pyliner/yamcs
                self.sock_map[message_client_id].send(to_send)
                tk.log('Instance', '[UNSUBSCRIBED] - '+message_client_id+' - '+msg, 'DEBUG')
            except:
                ## TODO: safely log error, unit test required
                tk.log('Instance', '[ERR - UNSUBSCRIBED] - ' + message_client_id + ' - ' + message_text, 'ERROR')
                pass
        ## kill all processes
        elif message_text.find('USALL')!=-1:
            try:
                to_kill_pid = self.proc_map[message_client_id]
                to_kill = psutil.Process(to_kill_pid)
                to_kill.kill()
                tk.log('Instance', '[KILLED] - ' + str(to_kill_pid), 'DEBUG')

            except:
                ## TODO: safely log error, unit test required
                tk.log('Instance', '[ERR - KILLED] - NA', 'ERROR')
                pass
        ## Subscribe signal
        ## Send message, start a system process, store current data in a local dict.
        elif message_text.find('tlm')!=-1:
            msg_text_obj = json.loads(message_text)
            temp = ' {"parameter":"subscribe", "data":{"list":' + str(tk.byteify(msg_text_obj['tlm'])) + '}}'
            temp = temp.replace("\'", "\"")
            to_send = '[1,1,0,' + str(temp) + ']'
            ## Train
            self.test_db_wrapper(message_text, 'null', 'SUBTLM', 'subscribe telemetry')
            ## One time per application cycle.
            if message_client_id not in self.sock_map.keys():
                try:
                    client_id = message.content['reply_channel']
                    ws = create_connection('ws://' + str(self.address) + ':' + str(self.port) + '/' + self.redis_cache.get('instance') + '/_websocket')
                    self.sock_map[client_id] = ws
                    self.sock_map[message_client_id].send(to_send)
                    process = Process(target=self.push,args=(self.sock_map[message_client_id],))
                    process.start()
                    self.proc_map[client_id] = process.pid
                    tk.log('Instance', '[PROCESS] - ' + str(process.pid) , 'DEBUG')
                except:
                    ## TODO: safely log error, unit test required
                    tk.log('Instance', '[ERR - PROCESS] - ' + message_client_id + ' - ' + message_text, 'ERROR')
                    pass
            ## If already a socket is created then continue and use that socket
            else:
                try:
                    self.sock_map[message_client_id].send(to_send)
                    tk.log('Instance', '[SUBSCRIBED] - ' + message_client_id + ' - ' + message_text, 'DEBUG')
                except:
                    ## TODO: safely log error, unit test required
                    tk.log('Instance', '[ERR - SUBSCRIBED] - ' + message_client_id + ' - ' + message_text, 'DEBUG')
                    pass

    def push(self, websocket_obj):
        """!
        A non-busy forever loop pushes telemetry to client.
        @param websocket_obj:  websocket object
        @return: void
        """
        freq_count = 1
        while True:
            try:
                result = websocket_obj.recv()
                ## If result is not a ACK signal, in YAMCS case ACK looks like `[1,2,x]`
                if result != '[1,2,0]':
                    result2 = tk.preProcess(result)
                    ## gets telemetry once every 10 loops
                    if self.test_sampling_frequency*freq_count == 1 :
                        ## Train
                        self.test_db_wrapper(result, result2, 'PREPROCTLM', 'preprocess telemetry before sending')
                        freq_count = 1
                    freq_count+=1
                    try:
                        Group('tlm_bc').send({'text': result2})
                    except:
                        time.sleep(1)
                        Group('tlm_bc').send({'text': result2})
            except:
                tk.log('Instance', 'Not able to push messages to client. Process killed.', 'ERROR')
                break
            ## avoids busy-while-loop
            time.sleep(0.01)

class Command:
    """!
    Deals with commanding specific interactions between client and server.
    """

    def __init__(self):
        """!
        Initializes globally required variables from redis cache and other data structures that are helpful in tracking
        messages when the instance of this class is called in a multiprocess setting (or with multiple workers).
        """
        ## Initialize redis caching database
        self.redis_cache = redis.StrictRedis(host='localhost', port=6379, db=0)

        ## Initialize mode defined in launch_config.json
        self.mode = int(self.redis_cache.get('mode'))

        ## Initialize test database path defined in launch_config.json
        self.test_db_path = self.redis_cache.get('app_path')

        ## Initialize default instance defined in launch_config.json
        self.defaultInstance = self.redis_cache.get('instance')

        ## Initialize address to pyliner/yamcs defined in launch_config.json
        self.address = self.redis_cache.get('address')

        ## Initialize port to pyliner/yamcs defined in launch_config.json
        self.port = self.redis_cache.get('port')

    def connect(self, message):
        """!
        Accepts request and establishes a connection with client.
        @param message: connection request from client, this message will connection headers.
        @return: void
        """
        message.reply_channel.send({'accept': True})
        tk.log(self.defaultInstance,'Commanding connected to  client','INFO')

    def disconnect(self, message):
        """!
        Accepts disconnection message and disconnects with client.
        @param message: disconnection request from client, this message will disconnection headers.
        @return: void
        """
        message.reply_channel.send({'close': True})
        tk.log('self.defaultInstance', 'Commanding (dis)connected from client', 'INFO')

    def test_db_wrapper(self,input,output,code,desc):
        """!
        This is a hook to record inputs and subsequent outputs that are generated by Command.
        @param input: a string object before a certain process is applied on it.
        @param output: a string object after the process is applied on it.
        @param code: a user defined string, categorizes various database entries.
        @param desc: description of the process that is applied on the input.
        @return: void
        """
        if self.mode == 0:
            try:
                conn = sqlite3.connect(self.test_db_path + '/test_database', timeout=5)
                tk.collectTestCases(conn, code, input, output, desc)
                conn.commit()
                conn.close()
                tk.log('Train', 'Item inserted in database.', 'DEBUG')
            except:
                ## TODO: safely log error, unit test required
                tk.log('Train', 'NA', 'ERROR')
                pass

    def getCommandInfo(self, message):
        """!
        Takes the command message object and requests commanding information from pyliner/yamcs.
        @param message: command message object is sent from the client.
        @return: void
        """
        message_text = message.content['text']
        ## got handshake
        if message_text == 'HS':
            message.reply_channel.send({'text': 'HSOK'})
        ## got command object
        else:
            if self.defaultInstance!='None':
                response = urllib.urlopen('http://' + str(self.address) + ':' + str(self.port) + '/api/mdb/'+ str(self.defaultInstance)+'/commands'+message_text)
            else:
                response = urllib.urlopen('http://' + str(self.address) + ':' + str(self.port) + '/api/mdb/'+ self.redis_cache.get('default_instance')+'/commands'+message_text)
            data = json.loads(json.dumps(response.read()))
            data = data.replace("\"", "\'")
            ## Train
            self.test_db_wrapper(message_text, data, 'CMDINFO', 'commanding information')
            message.reply_channel.send({'text':data})

    def postCommand(self, message):
        """!
        Takes the command message object and posts it to pyliner/yamcs.
        @param message: command message object is sent from the client.
        @return: void
        """
        message_text = message.content['text']
        to_post = json.loads(message_text)
        url=''
        if self.defaultInstance!='None':
            url = 'http://' + str(self.address) + ':' + str(self.port) +'/api/processors/' + str(self.defaultInstance) + '/realtime/commands' + to_post['name'] + '?nolink'
        else:
            url = 'http://' + str(self.address) + ':' + str(self.port) +'/api/processors/' + self.redis_cache.get('default_instance') + '/realtime/commands' + to_post['name'] + '?nolink'
        ## preparing post header
        msg = '{"sequenceNumber": 0,"origin": "user@my-machine","assignment":'+ str(json.dumps(to_post['args']))+',"dryRun": false}'
        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
        r = requests.post(url=url, data=msg, headers = headers)
        ## Train
        self.test_db_wrapper(message_text, r.status_code, 'CMDPOST', 'sending commands')
        got = r.text
        self.redis_cache.set('t_btn_cnt',str((int(self.redis_cache.get('t_btn_cnt'))+1)))
        op = json.dumps({"cmd":got,"code":r.status_code})
        message.reply_channel.send({'text': op})

class Instance:
    """!
    Deals with instance specific interactions between client and server.
    """
    def __init__(self):
        """!
        Initializes globally required variables from redis cache and other data structures that are helpful in tracking
        messages when the instance of this class is called in a multiprocess setting (or with multiple workers).
        """
        ## Initialize redis caching database
        self.redis_cache = redis.StrictRedis(host='localhost', port=6379, db=0)

        ## Initialize default instance defined in launch_config.json
        self.defaultInstance = self.redis_cache.get('instance')

        ## Initialize address to pyliner/yamcs defined in launch_config.json
        self.address = self.redis_cache.get('address')

        ## Initialize port to pyliner/yamcs defined in launch_config.json
        self.port = self.redis_cache.get('port')


    def connect(self, message):
        """!
        Accepts request and establishes a connection with client.
        @param message: connection request from client, this message will connection headers.
        @return: void
        """
        message.reply_channel.send({'accept': True})


    def disconnect(self, message):
        """!
        Accepts disconnection message and disconnects with client.
        @param message: disconnection request from client, this message will disconnection headers.
        @return: void
        """
        message.reply_channel.send({'close': True})


    def getInstanceList(self, message):
        """!
        This function is invoked by the client. Upon such an event, an instance list is requested from
        pyliner/yamcs which is forwarded to client.
        @param message: invoke signal sent from client
        @return: void
        """
        name = message.content['text']
        response = urllib.urlopen('http://' + str(self.address) + ':' + str(self.port) + '/api/instances')
        data = json.loads(json.dumps(response.read()))
        message.reply_channel.send({'text': data})


    def setDefaultInstance(self,message):
        """!
        Upon an instance being selected on the application, this method is called; which updates redis cache
        whith the latest instance.
        @param message: message contains active instance name.
        @return: void
        """
        name = message.content['text']
        self.defaultInstance = name
        self.redis_cache.set('instance',name)

class Directory:
    """!
    Deals with directory specific interactions between client and server.
    """
    def __init__(self):
        """!
        Initializes globally required variables from redis cache and other data structures that are helpful in tracking
        messages when the instance of this class is called in a multiprocess setting (or with multiple workers).
        """
        ## Initialize redis caching database
        self.redis_cache = redis.StrictRedis(host='localhost', port=6379, db=0)

        ## Initialize mode defined in launch_config.json
        self.mode = int(self.redis_cache.get('mode'))

        ## Initialize test database path defined in launch_config.json
        self.test_db_path = self.redis_cache.get('app_path')

        ## Initialize number or parallel workers defined in launch_config.json
        self.number_of_workers = self.redis_cache.get('number_of_workers')


    def connect(self,message):
        """!
        Accepts request and establishes a connection with client.
        @param message: connection request from client, this message will connection headers.
        @return: void
        """
        message.reply_channel.send({'accept': True})

    def disconnect(self,message):
        """!
        Accepts disconnection message and disconnects with client.
        @param message: disconnection request from client, this message will disconnection headers.
        @return: void
        """
        message.reply_channel.send({'close': True})

    def test_db_wrapper(self,input,output,code,desc):
        """!
        This is a hook to record inputs and subsequent outputs that are generated by Directory.
        @param input: a string object before a certain process is applied on it.
        @param output: a string object after the process is applied on it.
        @param code: a user defined string, categorizes various database entries.
        @param desc: description of the process that is applied on the input.
        @return: void
        """
        if self.mode == 0:
            try:
                conn = sqlite3.connect(self.test_db_path + '/test_database', timeout=5)
                tk.collectTestCases(conn, code, input, output, desc)
                conn.commit()
                conn.close()
                tk.log('Train', 'Item inserted in database.', 'DEBUG')
            except:
                ## TODO: safely log error, unit test required
                tk.log('Train', 'NA', 'ERROR')
                pass


    def directoryListing(self,message):
        """!
        Takes the file or directory name in the  message object, scrapes file system and sends out a json to client
        which has sub-directories listed.
        @param message: message object with directory or file name is sent from the client.
        @return: void
        """
        name = message.content['text']
        response = tk.get_directory(name)
        data = json.dumps(response)
        ## Train
        self.test_db_wrapper(name, data,'DIR','obtain directory listing')
        message.reply_channel.send({'text': data})
        tk.log('Directory',' Packet ' + name + ' sent.','INFO')

class Event:
    """!
    Deals with event specific interactions between client and server.
    """
    def __init__(self):
        """!
        Initializes globally required variables from redis cache and other data structures that are helpful in tracking
        messages when the instance of this class is called in a multiprocess setting (or with multiple workers).
        """
        ## Initialize redis caching database
        self.redis_cache = redis.StrictRedis(host='localhost', port=6379, db=0)

        ## Initialize default instance defined in launch_config.json
        self.defaultInstance = self.redis_cache.get('instance')

        ## Initialize address to pyliner/yamcs defined in launch_config.json
        self.address = self.redis_cache.get('address')

        ## Initialize port to pyliner/yamcs defined in launch_config.json
        self.port = self.redis_cache.get('port')

        ## A dictionary to store websockets which connect backend, mapped with unique id in message object.
        self.sock_map = {}

        ## A dictionary to store processes which push telemetry to frontend, mapped with unique id in message object.
        self.proc_map = {}

    def connect(self,message):
        """!
        Accepts request and establishes a connection with client.
        @param message: connection request from client, this message will connection headers.
        @return: void
        """
        message.reply_channel.send({'accept': True})

    def disconnect(self,message):
        """!
        Accepts disconnection message and disconnects with client.
        @param message: disconnection request from client, this message will disconnection headers.
        @return: void
        """
        message.reply_channel.send({'close': True})

    def getEvents(self,message):
        """!
        Upon receipt of invoke signal this function generates a process which pushes live event feeds to client.
        Upon receipt of kill signal the fucntion will kill the running process.
        @param message: event message object is sent from the client.
        @return: void
        """
        message_text = message.content['text']
        client_id = message.content['reply_channel']
        ## when invoke signal is received
        if message_text == 'INVOKE':
            data = '[1, 1, 1, {"events": "subscribe"}]'
            ws = None
            if self.defaultInstance == 'None':
                ws = create_connection('ws://' + self.address + ':' + str(self.port) + '/'+self.redis_cache.get('default_instance')+'/_websocket')
            else:
                ws = create_connection('ws://' + self.address + ':' + str(self.port) + '/'+self.defaultInstance+'/_websocket')
            ws.send(data)
            t = Process(target=self.push, args=(ws, message))
            self.proc_map[client_id] = t.pid
            self.sock_map[client_id] = ws
            t.start()
        # when kill signal is received
        elif message_text =='KILLSWITCH':
            try:
                us_sock = self.sock_map[client_id]
                data = '[1, 1, 1, {"events": "unsubscribe"}]'
                us_sock.send(data)
                tk.log('Event', '[UNSIBSCRIBED] - ' + client_id+' events', 'DEBUG')
            except:
                ## TODO: safely log error, unit test required
                tk.log('Event','Unable to unsubscribe.','ERROR')
                pass
            try:
                to_kill_pid = self.proc_map[client_id]
                to_kill = psutil.Process(to_kill_pid)
                to_kill.kill()
                tk.log('Event', '[KILLED] - ' + to_kill_pid, 'DEBUG')
            except:
                ## TODO: safely log error, unit test required
                tk.log('Event', 'Unable to kill.', 'ERROR')
                pass

    def push(self,websocket_obj,message_obj):
        """!
        A non-busy forever loop pushes events to client.
        @param websocket_obj:  websocket object
        @param message_obj:  message object
        @return: void
        """
        while True:
            result = websocket_obj.recv()
            ## If result is not a ACK signal, in YAMCS case ACK for events looks like `[1,4,x]`
            if result.find('[1,4,')!=-1 :
                #result = tk.preProcess(result)
                message_obj.reply_channel.send({'text': result})
                tk.log('Event', 'BOUND', 'INFO')
            ## avoids busy-while-loop
            time.sleep(0.01)

class Misc:
    """!
   Deals with all other interactions between client and server.
   """
    def __init__(self):
        """!
        Initializes globally required variables from redis cache and other data structures that are helpful in tracking
        messages when the instance of this class is called in a multiprocess setting (or with multiple workers).
        """
        ## Initialize redis caching database
        self.redis_cache = redis.StrictRedis(host='localhost', port=6379, db=0)

        ## Initialize default instance defined in launch_config.json
        self.defaultInstance = self.redis_cache.get('instance')

        ## Initialize address to pyliner/yamcs defined in launch_config.json
        self.address = self.redis_cache.get('address')

        ## Initialize port to pyliner/yamcs defined in launch_config.json
        self.adsb_port = self.redis_cache.get('adsb_port')

    def connect(self, message):
        """!
        Accepts request and establishes a connection with client.
        @param message: connection request from client, this message will connection headers.
        @return: void
        """
        message.reply_channel.send({'accept': True})

    def disconnect(self, message):
        """!
        Accepts disconnection message and disconnects with client.
        @param message: disconnection request from client, this message will disconnection headers.
        @return: void
        """
        message.reply_channel.send({'close': True})


    def getMisc(self, message):
        """!
        Invokes a flask API and gets ADS-B messages, which are forwarded to client.
        @param message: invoke message from client.
        @return: void
        """
        ## TODO: rewrite functionality, unit test required
        name = message.content['text']
        if name == 'START_COMM_HS':
            message.reply_channel.send({'text': 'START_COMM_ACK'})
        elif name == 'CLOSE_COMM_NOFBCK':
            tk.log('GET INSTANCE LIST', 'DISCONNECTING FROM SOCKET', 'INFO')
        else:
            response = urllib.urlopen('http://'+self.address+':'+str(self.adsb_port)+'/test')
            data = json.loads(json.dumps(response.read()))
            message.reply_channel.send({'text': data})
            tk.log(name, 'PACKET SENT', 'INFO')

class Video:
    """!
    Deals with video specific interactions between client and server.
    """
    def __init__(self):
        """!
        Initializes globally required variables from redis cache and other data structures that are helpful in tracking
        messages when the instance of this class is called in a multiprocess setting (or with multiple workers).
        """
        ## Initialize redis caching database.
        self.redis_cache = redis.StrictRedis(host='localhost', port=6379, db=0)

        ## Initialize default instance defined in launch_config.json.
        self.defaultInstance = self.redis_cache.get('instance')

        ## Initialize address to pyliner/yamcs defined in launch_config.json.
        self.address = self.redis_cache.get('address')

        ## Initialize video port to pyliner/yamcs defined in launch_config.json.
        self.video_port = self.redis_cache.get('video_port')

        ## A counter to count the number of frames processed.
        self.video_frame_counter = 0

        ## An empty variable which will be later used to store the video-udp socket object.
        self.video_socket = None


    def connect(self, message):
        """!
        Accepts request and establishes a connection with client.
        @param message: connection request from client, this message will connection headers.
        @return: void
        """
        message.reply_channel.send({'accept': True})


    def disconnect(self, message):
        """!
        Accepts disconnection message and disconnects with client.
        @param message: disconnection request from client, this message will disconnection headers.
        @return: void
        """
        message.reply_channel.send({'close': True})


    def getVideo(self, message):
        """!
        Invokes a continuous looping function which will push video images to client.
        @param message: invoke message from client.
        @return: void
        """
        name = message.content['text']
        self.VideoThroughUDP(message)


    def VideoThroughUDP(self,msg_obj):
        """!
        Binds with UDP port and forwards image data as and when received from pyliner/yamcs.
        @param msg_obj: ivoke message passed as parameter in `getVideo' function.
        @return: void
        """
        UDP_IP = self.address
        UDP_PORT = self.video_port
        ## UDP
        self.video_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
        self.video_socket.bind(("", UDP_PORT))
        while True:
            ## buffer size is 65527 bytes
            data, addr = self.video_socket.recvfrom(65527)
            b64_img = base64.b64encode(data)
            self.video_frame_counter = self.video_frame_counter + 1
            print 'Frame# : ['+str(self.video_frame_counter)+'] sent.'
            msg_obj.reply_channel.send({'text': b64_img})
            #yield b64_img

            ## avoids busy-while-loop
            time.sleep(0.01)

class MyCache:
    """!
   Loads launch variable to cache
    """
    def __init__(self):
        """!
        Initializes globally required variables from redis cache and other data structures that are helpful in tracking
        messages when the instance of this class is called in a multiprocess setting (or with multiple workers).
        """
        ## Initialize redis caching database
        self.redis_cache = redis.StrictRedis(host='localhost', port=6379, db=0)

    def initialize(self):
        """!
        Initializes redis cache with lauch variables which will persist through out the application.
        And performs certain housekeeping tasks.
        @return: void
        """
        try:
            with open(os.getcwd() + '/scripts/launch_config.json') as file:
                config = json.load(file)
                self.redis_cache.set ('instance',None)
                self.redis_cache.set('default_instance', config['pyliner']['default_instance'])
                self.redis_cache.set('address', config['pyliner']['address'])
                self.redis_cache.set('port', config['pyliner']['port'])
                self.redis_cache.set('video_port', config['pyliner']['video_port'])
                self.redis_cache.set('adsb_port', config['pyliner']['adsb_port'])
                self.redis_cache.set('number_of_workers', config['number_of_workers'])
                self.redis_cache.set('mode', config['mode'])
                self.redis_cache.set('app_path', config['app_path'])
                self.redis_cache.set('t_btn_cnt',0)

                ## clean test database, table
                if int(self.redis_cache.get('mode')) == 0:
                    conn = sqlite3.connect(self.redis_cache.get('app_path') + '/test_database', timeout=5)
                    c = conn.cursor()
                    ex = 'delete from TESTCASES'
                    c.execute(ex)
                    conn.commit()
                    conn.close()
            tk.log('Preconfiguration', 'Successful', 'INFO')
        except:
            ## TODO: safely log error, unit test required
            tk.log('Preconfiguration', 'Faliure - NA', 'ERROR')
            pass

